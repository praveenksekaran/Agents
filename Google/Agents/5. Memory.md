# Agent memory
An agent's ability to remember past interactions is fundamental to provide a coherent and useful conversational experience. To create stateful, context-aware agents, you must implement mechanisms for short-term memory and long-term memory. The following sections explore the design choices and Google Cloud services that you can use to implement both short-term and long-term memory for your agent.

[Refrence](https://docs.cloud.google.com/architecture/choose-agentic-ai-architecture-components)

#### Short-term memory
[Short-term memory](https://google.github.io/adk-docs/sessions/session/#the-session-lifecycle) enables an agent to maintain context within a single, ongoing conversation. To implement short-term memory, you must manage both the session and its associated state.

- Session: A session is the conversational thread between a user and the agent, from the initial interaction to the end of the dialogue.
- State: State is the data that the agent uses and collects within a specific session. The state data that's collected includes the history of messages that the user and agent exchanged, the results of any tool calls, and other variables that the agent needs in order to understand the context of the conversation.

The following are options for implementing short-term memory with ADK:

- In-memory storage: For development, testing, or simple applications that run on a single instance, you can store the session state directly in your application's memory. The agent uses a data structure, such as a dictionary or an object, to store a list of key-value pairs and it updates these values throughout the session. However, when you use in-memory storage, session state isn't persistent. If the application restarts, it loses all conversation history.
- External state management: For production applications that require scalability and reliability, we recommend that you build a stateless agent application and manage the session state in an external storage service. In this architecture, each time the agent application receives a request, it retrieves the current conversation state from the external store, processes the new turn, and then saves the updated state back to the store. This design lets you scale your application horizontally because any instance can serve any user's request.
- Common choices for external state management include Memorystore for Redis, Firestore, or Vertex AI Agent Engine sessions.

If you use ADK, the DatabaseSessionService requires a relational database, such as Cloud SQL.

#### Long-term memory
- Long-term memory provides the agent with a persistent knowledge base that exists across all conversations for individual users. Long-term memory lets the agent retrieve and use external information, learn from past interactions, and provide more accurate and relevant responses.

The following are options for implementing long-term memory with ADK:

- In-memory storage: For development and testing, you can store the session state directly in your application's memory. This approach is simple to implement, but it isn't persistent. If the application restarts, it loses the conversation history. You typically implement this pattern by using an in-memory provider within a development framework, such as the InMemoryMemoryService that's included in ADK for testing.
- External storage: For production applications, manage your agent's knowledge base in an external, persistent storage service. An external storage service ensures that your agent's knowledge is durable, scalable, and accessible across multiple application
   instances. Use Memory Bank for long-term storage with any agent runtime on Google Cloud.

## Memory Bank
[Vertex AI Agent Engine Memory Bank](https://docs.cloud.google.com/agent-builder/agent-engine/memory-bank/overview) lets you dynamically generate long-term memories based on users' conversations with your agent. Long-term memories are personalized information that can be accessed across multiple sessions for a particular user. The agent can use the memories to personalize responses to the user and create cross-session continuity.

# The `Session` Object

[Google Documentation](https://google.github.io/adk-docs/sessions/session/#example-examining-session-properties)

When a user starts interacting with your agent, the `SessionService` creates a `Session` object (`google.adk.sessions.Session`)
This object acts as the container holding everything related to that one specific chat thread. 
Here are its key properties
- **Identification** (id, appName, userId): Unique labels for the conversation
- **History (events)**: A chronological sequence of all interactions (Event objects â€“ user messages, agent responses, tool actions) that have occurred within this specific thread
- **Session State (state)**: A place to store temporary data relevant only to this specific, ongoing conversation. This acts as a scratchpad for the agent during the interaction. We will cover how to use and manage state in detail in the next section.
- **Activity Tracking (lastUpdateTime)**: A timestamp indicating the last time an event occurred in this conversation thread

```
 from google.adk.sessions import InMemorySessionService, Session

 # Create a simple session to examine its properties
 temp_service = InMemorySessionService()
 example_session = await temp_service.create_session(
     app_name="my_app",
     user_id="example_user",
     state={"initial_key": "initial_value"} # State can be initialized
 )

 print(f"--- Examining Session Properties ---")
 print(f"ID (`id`):                {example_session.id}")
 print(f"Application Name (`app_name`): {example_session.app_name}")
 print(f"User ID (`user_id`):         {example_session.user_id}")
 print(f"State (`state`):           {example_session.state}") # Note: Only shows initial state here
 print(f"Events (`events`):         {example_session.events}") # Initially empty
 print(f"Last Update (`last_update_time`): {example_session.last_update_time:.2f}")
 print(f"---------------------------------")

 # Clean up (optional for this example)
 temp_service = await temp_service.delete_session(app_name=example_session.app_name,
                             user_id=example_session.user_id, session_id=example_session.id)
 print("The final status of temp_service - ", temp_service)
```

## Managing Sessions with a SessionService
 you don't typically create or manage Session objects directly. Instead, you use a SessionService. This service acts as the central manager responsible for the entire lifecycle of your conversation sessions

- Starting New Conversations
- Resuming Existing Conversations: using its ID
- Saving Progress: Appending new interactions (Event objects) to a session's history.
- Listing Conversations: Finding the active session threads for a particular user and application.
- Cleaning Up: Deleting Session objects and their associated data when conversations are finished or no longer needed.

## SessionService Implementations

ADK provides different SessionService implementations, allowing you to choose the storage backend that best suits your needs:

1. **InMemorySessionService**
   Stores all session data directly in the application's memory. All conversation data is lost if the application restarts
2. **VertexAiSessionService**
   Uses Google Cloud Vertex AI infrastructure via API calls for session management. Persistence. Data is managed reliably and scalably via Vertex AI Agent Engine.
3. **DatabaseSessionService**
   Connects to a relational database (e.g., PostgreSQL, MySQL, SQLite) to store session data persistently in tables.Persistence.

## Session
- `Start or resume` applications use sessionservice or create_session, 
- `Runner` get Session object
- Agent process prompt + session `state` and `events` history
- Agent respose updated in `state` and Runner packages this as `Event`
- `Runner` calls session append to save state, events and last updated time
- Agent respinse is sent to user and Session is ready next run
- on session end application calls SessionService delete
  
<img width="1710" height="790" alt="image" src="https://github.com/user-attachments/assets/a3af61b0-c21b-4a77-a54c-24b6aac30e0c" />


# Rewind sessions for agents
The ADK session Rewind feature allows you to revert a session to a previous request state, enabling you to undo mistakes, explore alternative paths, or restart a process from a known good point. This document provides an overview of the feature, how to use it, and its limitations

# State

[Google Docs](https://google.github.io/adk-docs/sessions/state/)

Within each `Session` (our conversation thread), the **`state`** attribute acts like the agent's dedicated scratchpad for that specific interaction

## What is `session.state`?
Conceptually, session.state is a collection (dictionary or Map) holding key-value pairs

#### Key Characterstics of state 
1. Data is stored as key: value
2. Keys: Always strings (str). Use clear names (e.g., 'departure_city', 'user:language_preference')
3. Values: Must be serializable. like strings, numbers, booleans, and simple lists or dictionaries containing only these basic types
4. The contents of the state are expected to change as the conversation evolves.
5. Persistence: Depends on SessionService (InMemorySessionService, VertexAISessionService, DatabaseSessionService)

#### Organizing State with Prefixes: Scope Matters
1. No Prefix: Scope, Specific to the current session (id). persistance depends on SessionService. Example: session.state['current_intent'] = 'book_flight'
2. `user`: Prefix (User State): Scope, Tied to the user_id, shared across all sessions for that user (within the same app_name). Example: `session.state['user:preferred_language'] = 'fr'`
3. `app`: Prefix (App State): Scope, Tied to the app_name, shared across all users and sessions for that application. Example: `session.state['app:global_discount_code'] = 'SAVE10'`
4. `temp`: Prefix (Temporary Invocation State): Scope, Specific to the current invocation (the entire process from an agent receiving user input to generating the final output for that input). Example: `session.state['temp:raw_api_response'] = {...}`

#### Accessing Session State in Agent Instructions
When working with `LlmAgent` instances, you can directly inject session state values into the agent's instruction string using a simple templating syntax using `{key}`. To use a key that may or may not be present, you can include a question mark (?) after the key (e.g. `{topic?}`). If you need to use literal curly braces in your instruction (e.g., for JSON formatting), you'll need to escape them.

#### Bypassing State Injection with `InstructionProvider` 
use `{{....}}`
`InstructionProvider` is a function used to bypass ADK into injecting the state. you might need this for an Agent that helps with a templating language that uses the same syntax. The InstructionProvider function receives a ReadonlyContext object, which you can use to access session state or other contextual information if you need to build the instruction dynamically.

```
from google.adk.agents import LlmAgent
from google.adk.agents.readonly_context import ReadonlyContext

# This is an InstructionProvider
def my_instruction_provider(context: ReadonlyContext) -> str:
    # You can optionally use the context to build the instruction
    # For this example, we'll return a static string with literal braces.
    return "This is an instruction with {{literal_braces}} that will not be replaced."

agent = LlmAgent(
    model="gemini-2.0-flash",
    name="template_helper_agent",
    instruction=my_instruction_provider
)
```
If you want to both use an InstructionProvider and inject state into your instructions, you can use the inject_session_state utility function

```
from google.adk.agents import LlmAgent
from google.adk.agents.readonly_context import ReadonlyContext
from google.adk.utils import instructions_utils

async def my_dynamic_instruction_provider(context: ReadonlyContext) -> str:
    template = "This is a {adjective} instruction with {{literal_braces}}."
    # This will inject the 'adjective' state variable but leave the literal braces.
    return await instructions_utils.inject_session_state(template, context)

agent = LlmAgent(
    model="gemini-2.0-flash",
    name="dynamic_template_helper_agent",
    instruction=my_dynamic_instruction_provider
)
```

## How State is Updated

1. The Easy Way: `output_key` (for Agent Text Responses)
   This is the simplest method for saving an agent's final text response directly into the state. When defining your LlmAgent, specify the output_key:
   ```
   greeting_agent = LlmAgent(
       name="Greeter",
       model="gemini-2.0-flash", # Use a valid model
       instruction="Generate a short, friendly greeting.",
       output_key="last_greeting" # Save response to state['last_greeting']
   )
   ```
2. The Standard Way: EventActions.state_delta (for Complex Updates)
   For more complex scenarios (updating multiple keys, non-string values, specific scopes like user: or app:, or updates not tied directly to the agent's final text), you manually construct the state_delta within EventActions.

 3. Via CallbackContext or ToolContext (Recommended for Callbacks and Tools)

# Memory: Long-Term

[Google Docs](https://google.github.io/adk-docs/sessions/memory/)

if an agent needs to recall information from past conversations? This is where the concept of Long-Term Knowledge and the MemoryService come into play.
Long-Term Knowledge (MemoryService): Like a searchable archive or knowledge library the agent can consult, potentially containing information from many past chats or other sources.

#### The MemoryService Role

The BaseMemoryService defines the interface for managing this searchable, long-term knowledge store. Its primary responsibilities are:

1. **Ingesting Information** (add_session_to_memory): Taking the contents of a (usually completed) Session and adding relevant information to the long-term knowledge store.
2. **Searching Information** (search_memory): Allowing an agent (typically via a Tool) to query the knowledge store and retrieve relevant snippets or context based on a search query.

#### Memory Service
The ADK offers two distinct MemoryService implementations, each tailored to different use cases. Use the table below to decide which is the best fit for your agent.
1. In-Memory Memory
2. Vertex AI Memory Bank




