# Agent memory
An agent's ability to remember past interactions is fundamental to provide a coherent and useful conversational experience. To create stateful, context-aware agents, you must implement mechanisms for short-term memory and long-term memory. The following sections explore the design choices and Google Cloud services that you can use to implement both short-term and long-term memory for your agent.

[Refrence](https://docs.cloud.google.com/architecture/choose-agentic-ai-architecture-components)

#### Short-term memory
[Short-term memory](https://google.github.io/adk-docs/sessions/session/#the-session-lifecycle) enables an agent to maintain context within a single, ongoing conversation. To implement short-term memory, you must manage both the session and its associated state.

- Session: A session is the conversational thread between a user and the agent, from the initial interaction to the end of the dialogue.
- State: State is the data that the agent uses and collects within a specific session. The state data that's collected includes the history of messages that the user and agent exchanged, the results of any tool calls, and other variables that the agent needs in order to understand the context of the conversation.

The following are options for implementing short-term memory with ADK:

- In-memory storage: For development, testing, or simple applications that run on a single instance, you can store the session state directly in your application's memory. The agent uses a data structure, such as a dictionary or an object, to store a list of key-value pairs and it updates these values throughout the session. However, when you use in-memory storage, session state isn't persistent. If the application restarts, it loses all conversation history.
- External state management: For production applications that require scalability and reliability, we recommend that you build a stateless agent application and manage the session state in an external storage service. In this architecture, each time the agent application receives a request, it retrieves the current conversation state from the external store, processes the new turn, and then saves the updated state back to the store. This design lets you scale your application horizontally because any instance can serve any user's request.
- Common choices for external state management include Memorystore for Redis, Firestore, or Vertex AI Agent Engine sessions.

If you use ADK, the DatabaseSessionService requires a relational database, such as Cloud SQL.

#### Long-term memory
- Long-term memory provides the agent with a persistent knowledge base that exists across all conversations for individual users. Long-term memory lets the agent retrieve and use external information, learn from past interactions, and provide more accurate and relevant responses.

The following are options for implementing long-term memory with ADK:

- In-memory storage: For development and testing, you can store the session state directly in your application's memory. This approach is simple to implement, but it isn't persistent. If the application restarts, it loses the conversation history. You typically implement this pattern by using an in-memory provider within a development framework, such as the InMemoryMemoryService that's included in ADK for testing.
- External storage: For production applications, manage your agent's knowledge base in an external, persistent storage service. An external storage service ensures that your agent's knowledge is durable, scalable, and accessible across multiple application
   instances. Use Memory Bank for long-term storage with any agent runtime on Google Cloud.

## Memory Bank
[Vertex AI Agent Engine Memory Bank](https://docs.cloud.google.com/agent-builder/agent-engine/memory-bank/overview) lets you dynamically generate long-term memories based on users' conversations with your agent. Long-term memories are personalized information that can be accessed across multiple sessions for a particular user. The agent can use the memories to personalize responses to the user and create cross-session continuity.
